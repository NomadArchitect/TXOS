# Debug 指南

## VS Code Debug

> **调试 C/C++ 程序需要安装 C/C++ 插件，再进行以下配置。**

### 配置文件

VS Code 的调试主要由 `launch.json` 和 `tasks.json` 两个配置文件负责。这两个文件可以理解成高级版的 `Makefile`，因为其本质仍然是执行命令。

`launch.json` 表示调试的配置，包括调试文件位置（`"program"`），调试工具位置（`"miDebuggerPath"`）等等。

其中的预先任务（`"preLaunchTask"`）表示进行调试前需要进行的任务，一般为编译。

这个预先任务（`"preLaunchTask“`）和 `tasks.json` 中的配置的（`"label"`）相对应，表示应预先执行哪个任务；如果没有指定预先任务，那么就不会执行任何预先操作。

调试文件位置（`"program"`）尽量和 `Makefile` 文件保持在同一个目录下，这样可以在 VS Code 工作台为空时，仍能正确的触发调试。

`launch.json` 配置文件：

```json
{
    "name": "gcc - Build and debug active file",
    "type": "cppdbg",
    "request": "launch",
    "program": "${fileDirname}/${fileBasenameNoExtension}.out",
    "args": [],
    "stopAtEntry": false,
    "cwd": "${fileDirname}",
    "environment": [],
    "externalConsole": false,
    "MIMode": "gdb",
    "setupCommands": [
        {
            "description": "Enable pretty-printing for gdb",
            "text": "-enable-pretty-printing",
            "ignoreFailures": true
        },
        {
            "description": "Set Disassembly Flavor to Intel",
            "text": "-gdb-set disassembly-flavor intel",
            "ignoreFailures": true
        }
    ],
    "preLaunchTask": "C/C++: gcc build active file",
    "miDebuggerPath": "/usr/bin/gdb"
}
```

`tasks.json` 配置文件：

```json
{
    "type": "shell",
    "label": "C/C++: gcc build active file",
    "command": "/usr/bin/gcc",
    "args": [
        "-fdiagnostics-color=always",
        "-m32", // 编译成 32 位的程序
        "-g",
        "-I${workspaceFolder}/src/include",
        "${file}",
        "-o",
        "${fileDirname}/${fileBasenameNoExtension}.out"
    ],
    "options": {
        "cwd": "${fileDirname}"
    },
    "problemMatcher": [
        "$gcc"
    ],
    "group": {
        "kind": "build",
        "isDefault": true
    },
    "detail": "Task generated by Debugger."
}
```

### 调试控制台

在调试控制台可以输入调试指令，以下为比较常用的调试指令：

```bash
# 打印当前栈顶开始的 8 个字（这里一个字为 32 bits）
-exec display/8xw $sp

# 将地址 $sp + 12 处的值（{int} 指示修改 4 个字节）修改为 0x444
-exec set {int}($sp + 12) = 0x444

# 打印 0x080497e6 地址处的指令
-exec x/i 0x080497e6

# 打印 0x080497e6 地址开始的 10 条指令
-exec x/10i 0x080497e6
```

调试控制台也可以和监视区域一样，打印某些变量的值：

```bash
a, x # 以十六进制打印变量 a
s, s # 以字符串格式打印变量 s
```

### 反汇编

C/C++ 插件有反汇编功能，在安装 C/C++ 插件并且配置好调试设置文件后，进入调试模式并停在断点时，右键选择 **Open Disassembly View** 选项，即可看到在当前断点处，源代码上下文对应的汇编代码。

## Qemu Debug

使用 Bochs 可以在图形化界面查询：物理地址或虚拟地址处的数据、页表、寄存器的值等等，这对于调试排错是非常有用的。对于 Qemu 来说，我们也可以查询这些信息，但是是通过命令行界面的。

首先需要在 Qemu 界面的 **View** 选项处，勾选 **Show Tabs**。然后在原菜单栏下方就会出现新的选项，比如 **VGA** 就是我们用于显示我们写的系统的打印信息。我们需要点击 **compact-monitor0**，然后就可以在这个命令行界面输入命令来获取我们需要的信息了。

以下为常用的命令：

- `info registers`：输出所有寄存器的值

- `info tlb`：输出 TLB 中的内容，常用于观察页表
